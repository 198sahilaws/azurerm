#!/usr/bin/env bash

set -eo pipefail

usage()
{
    echo "Usage: $0 <up|destroy>"
    exit 1
}

if [ $# -ne 1 ] ; then
    usage
else
    case $1 in
      up|destroy|do)
          oper=$1
      ;;
      *)
          usage
      ;;
    esac
fi

if [[ "$oper" == "up" ]]; then
    # shellcheck disable=SC2153
    if [ -z "$dtype" ]; then
    while true; do
     read -r -p "Deployment: ( greenfield | brownfield ): " deploy

    case $deploy in
      greenfield)
      echo ""
      echo "**Caution** These deployments include test workloads and publicly accessible jump hosts and are intended primarily for lab/test environments"
      echo ""
          break
      ;;
      brownfield)
          break
      ;;    
      *)
          echo "Invalid Deployment Type: ${dtype}"
      ;;
    esac
  done
    
    while [ "$deploy" == "greenfield" ]; do
     read -r -p "Deployment Type: ( base | base_1cc | base_1cc_zpa | base_cc_lb | base_cc_lb_zpa ) : " dtype

    case $dtype in
      base|base_1cc|base_1cc_zpa|base_cc_lb|base_cc_lb_zpa)
          echo "Deployment Type: ${dtype}"
          break
      ;;
      *)
          echo "Invalid Deployment Type: ${dtype}"
      ;;
    esac
  done
    
    while [ "$deploy" == "brownfield" ]; do
     read -r -p "Deployment Type: ( cc_lb ) : " dtype

    case $dtype in
      cc_lb)
          echo "Deployment Type: ${dtype}"
          break
      ;;
      *)
          echo "Invalid Deployment Type: ${dtype}"
      ;;
    esac
  done
    
    else
      dtype=$dtype
    fi
fi

echo "Discovering processor architecture..."
archdetect=$(uname -m)

tversion=1.1.9
echo "Detecting OS..."
if [[ "$OSTYPE" == "linux"* ]]; then
    os_str=linux
    arch=amd64
    ostype=Linux
elif [[ "$OSTYPE" == "darwin"* && $archdetect == "arm64" ]]; then
    os_str=darwin
    arch=arm64
    ostype=MacOS_arm64
elif [[ "$OSTYPE" == "darwin"* ]]; then
    os_str=darwin
    arch=amd64
    ostype=MacOS
elif [[ "$OSTYPE" == "freebsd"* ]]; then
    os_str=freebsd
    arch=amd64
    ostype=FreeBSD
    echo "FreeBSD support coming soon..."
    exit 1
else
    echo "Unsupported OS: $OSTYPE"
    exit 1
fi
echo "OS is $ostype"

dir=bin
echo "Creating a local $dir directory if not present..."
if [[ ! -e $dir ]]; then
    mkdir $dir
elif [[ ! -d $dir ]]; then
    echo "$dir already exists but is not a directory" 1>&2
    exit 1
fi

az_regions=["westus","West US","westus2","West US 2","eastus","East US","centralus","Central US","centraluseuap","Central US EUAP","southcentralus","South Central US","northcentralus","North Central US","westcentralus","West Central US","eastus2","East US 2","eastus2euap","East US 2 EUAP","brazilsouth","Brazil South","northeurope","North Europe","westeurope","West Europe","eastasia","East Asia","southeastasia","Southeast Asia","japanwest","Japan West","japaneast","Japan East","koreacentral","Korea Central","koreasouth","Korea South","southindia","South India","westindia","West India","centralindia","Central India","australiaeast","Australia East","australiasoutheast","Australia Southeast","canadacentral","Canada Central","canadaeast","Canada East","uksouth","UK South","ukwest","UK West","francecentral","France Central","francesouth","France South","australiacentral","Australia Central","australiacentral2","Australia Central 2","uaecentral","UAE Central","uaenorth","UAE North","southafricanorth","	South Africa North","southafricawest","South Africa West","switzerlandnorth","Switzerland North","switzerlandwest","Switzerland West","germanynorth","Germany North","germanywestcentral","Germany West Central","norwayeast","Norway East","norwaywest","Norway West","brazilsoutheast","Brazil Southeast","westus3","West US 3","swedencentral","Sweden Central","swedensouth","Sweden South","chinaeast","China East","ChinaEast","chinaeast2","China East 2","ChinaEast2","chinanorth","China North","ChinaNorth","chinanorth2","China North 2","ChinaNorth2","chinanorth3","China North 3","ChinaNorth3"] 
# if .zsecrc is not present we'll assume that Azure env was never set
if [[ $dtype == "base" && ! -e ./.zsecrc ]]; then
    echo "Checking Azure Environment Variables..."
    read -r -p "Enter Azure Subcription ID: " azure_subscription_id
    echo "export ARM_SUBSCRIPTION_ID=${azure_subscription_id}" > .zsecrc
    echo "export TF_VAR_env_subscription_id=${azure_subscription_id}" >> .zsecrc
    read -r -p "Enter Directory (tenant) ID: " azure_tenant_id
    echo "export ARM_TENANT_ID=${azure_tenant_id}" >> .zsecrc
    read -r -p "Enter Application (client) ID of Service Principal: " azure_client_id
    echo "export ARM_CLIENT_ID=${azure_client_id}" >> .zsecrc
    read -r -p "Enter Client Secret Value of Service Principal: " azure_client_secret
    echo "export ARM_CLIENT_SECRET=${azure_client_secret}" >> .zsecrc
    read -r -p "Enter Azure Region (e.g. westus2): " azure_location
    if [[ ${az_regions[*]} =~ $azure_location ]]; then
    echo "export TF_VAR_arm_location='$azure_location'" >> .zsecrc
        if [[ ${azure_location,,} = "china"*  ]]; then
            echo "Azure China region detected. Setting ARM_ENVIRONMENT..."
            echo "export ARM_ENVIRONMENT=china" >> .zsecrc
        fi
    else
    echo "Invalid Azure region name entered."
    echo "Delete .zsecrc file and re-run zsec up..."
    exit 1
    fi
    while [[ "$dtype" == "base" && "$oper" == "up" ]]; do
clientpublicip=$(curl -s ifconfig.me)
    echo "greenfield deployments include a publicly accessible ssh bastion host.."
    read -r -p "Your current public IP is ${clientpublicip}. Lock SSH access to this IP? [yes/no] " bastion_response
case $bastion_response in 
	yes|y ) 
    echo "Updating Bastion NSG to permit SSH only from ${clientpublicip}: "
    echo "export TF_VAR_bastion_nsg_source_prefix=${clientpublicip}" >> .zsecrc
    useclientip=true
    break
    ;;
	no|n )
    useclientip=false
    break
    ;;
	* ) echo "invalid response. Please enter yes or no";;
    esac
done

if [[ "$useclientip" == "false" ]]; then
while true; do
read -r -p "Lock SSH access to a different IP address or range? Default is open [yes/no]: " changebastionip
case $changebastionip in 
	yes|y ) 
    read -r -p "Enter new IP Address or CIDR range (e.g. 2.2.2.2/32): " bastionipinput
    echo "export TF_VAR_bastion_nsg_source_prefix=${bastionipinput}" >> .zsecrc

if [[ $bastionipinput =~ ^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\/(3[0-2]|[1-2][0-9]|[1-9]))$ ]]
    then
    echo "$bastionipinput - IP/Netmask valid"
    else
    echo "$bastionipinput is not valid IP CIDR format"
    echo "Delete .zsecrc file and re-run zsec up..."
    exit 1
fi
    break
    ;;
	no|n )
    echo "SSH access permitted for all IP addresses..." 
    break
    ;;
	* ) echo "invalid response. Please enter yes or no";;
    esac
done
fi
fi

echo "Checking Azure Environment Variables and Cloud Connector bootstrap requirements... For ZPA or custom/byo deployments, please stop and refer to the README and terraform.tfvars file instructions"
# if .zsecrc is not present we'll assume that Azure env was never set
if [[ ! -e ./.zsecrc ]]; then
    read -r -p "Enter Azure Subcription ID: " azure_subscription_id
    echo "export ARM_SUBSCRIPTION_ID=${azure_subscription_id}" > .zsecrc
    echo "export TF_VAR_env_subscription_id=${azure_subscription_id}" >> .zsecrc
    read -r -p "Enter Directory (tenant) ID: " azure_tenant_id
    echo "export ARM_TENANT_ID=${azure_tenant_id}" >> .zsecrc
    read -r -p "Enter Application (client) ID of Service Principal: " azure_client_id
    echo "export ARM_CLIENT_ID=${azure_client_id}" >> .zsecrc
    read -r -p "Enter Client Secret Value of Service Principal: " azure_client_secret
    echo "export ARM_CLIENT_SECRET=${azure_client_secret}" >> .zsecrc
    read -r -p "Enter Azure Region (e.g. westus2): " azure_location
    if [[ ${az_regions[*]} =~ $azure_location ]]; then
    echo "export TF_VAR_arm_location='$azure_location'" >> .zsecrc
        if [[ ${azure_location,,} = "china"*  ]]; then
            echo "Azure China region detected. Setting ARM_ENVIRONMENT..."
            echo "export ARM_ENVIRONMENT=china" >> .zsecrc
        fi
    else
    echo "Invalid Azure region name entered."
    echo "Delete .zsecrc file and re-run zsec up..."
    exit 1
    fi

    while [[ "$dtype" == "base"* && "$oper" == "up" ]]; do
clientpublicip=$(curl -s ifconfig.me)
    echo "greenfield deployments include a publicly accessible ssh bastion host.."
    read -r -p "Your current public IP is ${clientpublicip}. Lock SSH access to this IP? [yes/no] " bastion_response
case $bastion_response in 
	yes|y ) 
    echo "Updating Bastion NSG to permit SSH only from ${clientpublicip}: "
    echo "export TF_VAR_bastion_nsg_source_prefix=${clientpublicip}" >> .zsecrc
    useclientip=true
    break
    ;;
	no|n )
    useclientip=false
    break
    ;;
	* ) echo "invalid response. Please enter yes or no";;
    esac
done

if [[ "$useclientip" == "false" ]]; then
while true; do
read -r -p "Lock SSH access to a different IP address or range? Default is open [yes/no]: " changebastionip
case $changebastionip in 
	yes|y ) 
    read -r -p "Enter new IP Address or CIDR range (e.g. 2.2.2.2/32): " bastionipinput
    echo "export TF_VAR_bastion_nsg_source_prefix=${bastionipinput}" >> .zsecrc

if [[ $bastionipinput =~ ^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\/(3[0-2]|[1-2][0-9]|[1-9]))$ ]]
    then
    echo "$bastionipinput - IP/Netmask valid"
    else
    echo "$bastionipinput is not valid IP CIDR format"
    echo "Delete .zsecrc file and re-run zsec up..."
    exit 1
fi
    break
    ;;
	no|n )
    echo "SSH access permitted for all IP addresses..." 
    break
    ;;
	* ) echo "invalid response. Please enter yes or no";;
    esac
done
fi

    # ---
    # Host Encryption Support
    encryption_at_host_enabled=true
    # Sourcing .zsecrc to use credentials during execution
    source .zsecrc

    while true; do
        read -r -p "Do you want to enable the Azure host encryption feature? [Default setting is Yes]: " input

        # Convert the user input to lowercase for case-insensitive comparison
        input=$(echo "$input" | tr '[:upper:]' '[:lower:]')

        if [[ "$input" == "no" || "$input" == "n" ]]; then
            echo "Setting encryption_at_host_enabled to false..."
            encryption_at_host_enabled=false
            break
        elif [[ "$input" == "yes" || "$input" == "y" || -z "$input" ]]; then
            echo "Checking if EncryptionAtHost feature is enabled for subscription $ARM_SUBSCRIPTION_ID..."

            TOKEN_ENDPOINT="https://login.microsoftonline.com/${ARM_TENANT_ID}/oauth2/token"
            RESOURCE="https://management.azure.com/"
            ACCESS_TOKEN=$(curl -s -X POST -H "Content-Type: application/x-www-form-urlencoded" \
                -d "grant_type=client_credentials" \
                -d "client_id=${ARM_CLIENT_ID}" \
                -d "client_secret=${ARM_CLIENT_SECRET}" \
                -d "resource=${RESOURCE}" \
                "${TOKEN_ENDPOINT}" | grep -o '"access_token":"[^"]*' | awk -F'"' '{print $4}')
            
            response=$(curl -s -X GET -H "Authorization: Bearer ${ACCESS_TOKEN}" \
                "https://management.azure.com/subscriptions/$ARM_SUBSCRIPTION_ID/providers/Microsoft.Features/providers/Microsoft.Compute/features/EncryptionAtHost?api-version=2021-07-01" \
                |grep -o '"state":"[^"]*' | awk -F'"' '{print $4}')

            if [ "$response" = "Registered" ]; then
                echo "EncryptionAtHost feature is enabled for subscription $ARM_SUBSCRIPTION_ID..."
                echo "Setting encryption_at_host_enabled to true..."
                encryption_at_host_enabled=true
            else
                echo "Error: Azure Subscription $ARM_SUBSCRIPTION_ID is not registered to support host encryption. Please refer to documentation."
                exit 1    
            fi
            break
        else
            echo "Invalid input. Please enter 'yes' or 'no'."
        fi
    done

    echo "export TF_VAR_encryption_at_host_enabled=${encryption_at_host_enabled}" >> .zsecrc
    # End of Host Encryption support update
    # ---


    cc_instance_size=small
    echo "export TF_VAR_cc_instance_size=${cc_instance_size}" >> .zsecrc
    #read -r -p "Enter CC Instance Size. Valid input = small, medium, or large. This needs to match the size chosen in the CC provisioning template [Default=$cc_instance_size_default]: " cc_instance_size_input
#cc_instance_size=${cc_instance_size_input:-$cc_instance_size_default}
#    case $cc_instance_size in
#      small|medium|large)
#          echo "Cloud Connector size: ${cc_instance_size}"
#          echo "export TF_VAR_cc_instance_size=${cc_instance_size}" >> .zsecrc
#      ;;
#      *)
#          echo "Invalid Cloud Connector size: ${cc_instance_size}."
#          echo "Delete .zsecrc file and re-run zsecup ..."
#          exit 1
#      ;;
#    esac

ccvm_instance_type_default=Standard_D2s_v3
while true; do
    read -r -p "Enter desired Azure VM type for CC. Recommended types: Small CC (Standard_D2s_v3) [Default=$ccvm_instance_type_default]: " ccvm_instance_type_input
ccvm_instance_type=${ccvm_instance_type_input:-$ccvm_instance_type_default}
case $ccvm_instance_type in 
	Standard_D2s_v3|Standard_DS3_v2|Standard_D8s_v3|Standard_D16s_v3|Standard_DS5_v2 ) 
    echo "Cloud Connector VM type: ${ccvm_instance_type}"
    echo "export TF_VAR_ccvm_instance_type=${ccvm_instance_type}" >> .zsecrc
    break
    ;;
	*)
    echo "Invalid Cloud Connector VM type: ${ccvm_instance_type}. Please enter an approved VM type"
    esac
done 

small_cc_instance=("Standard_D2s_v3" "Standard_DS3_v2" "Standard_D8s_v3" "Standard_D16s_v3" "Standard_DS5_v2")
medium_cc_instance=("Standard_D8s_v3" "Standard_DS3_v2" "Standard_D16s_v3" "Standard_DS5_v2")
large_cc_instance=("Standard_D16s_v3" "Standard_DS5_v2")

if [[ ${small_cc_instance[*]} =~ $ccvm_instance_type && "$cc_instance_size" == small ]]; then
echo "Proceeding. ${ccvm_instance_type} compatible with ${cc_instance_size} Cloud Connector size"
elif [[ ${medium_cc_instance[*]} =~ $ccvm_instance_type && "$cc_instance_size" == medium ]]; then
echo "Proceeding. ${ccvm_instance_type} compatible with ${cc_instance_size} Cloud Connector size"
elif [[ ${large_cc_instance[*]} =~ $ccvm_instance_type && "$cc_instance_size" == large ]]; then
echo "Proceeding. ${ccvm_instance_type} compatible with ${cc_instance_size} Cloud Connector size"
elif [[ $dtype == base ]]; then
echo "Proceeding with no CCs to deploy"
else
    echo "Invalid CC deployment. ${ccvm_instance_type} not compatible with ${cc_instance_size} Cloud Connector size"
    echo "Delete .zsecrc file and re-run zsec up..."
    exit 1
fi
    read -r -p "Enter CC Provisioning URL (E.g. connector.zscaler.net/api/v1/provUrl?name=azure_prov_url): " cc_vm_prov_url
    echo "Provisioning URL entered is: $cc_vm_prov_url. Make sure this matches the CC Instance Size $cc_instance_size chosen."
    echo "export TF_VAR_cc_vm_prov_url=${cc_vm_prov_url}" >> .zsecrc
    read -r -p "Enter Azure Key Vault URL (E.g https://zscaler-cc-demo.vault.azure.net): " azure_vault_url
    echo "Key Vault URL entered is: $azure_vault_url"
    echo "export TF_VAR_azure_vault_url=${azure_vault_url}" >> .zsecrc
http_probe_port_default=50000
    read -r -p "Enter CC service health probe TCP port number. Valid input = 80 or any number between 1024-65535 [Default=$http_probe_port_default]: " http_probe_port_input
http_probe_port=${http_probe_port_input:-$http_probe_port_default}
if ((http_probe_port == 80 || http_probe_port >= 1024 && http_probe_port <= 65535)); then
    echo "Valid HTTP probe port input of $http_probe_port"
    echo "export TF_VAR_http_probe_port=${http_probe_port}" >> .zsecrc
else
    echo "Invalid HTTP probe port value"
    echo "Delete .zsecrc file and re-run zsec up..."
    exit 1
fi
    echo "Cloud Connector User Managed Identity Information:"
while true; do
    read -r -p "Is the Managed Identity in the same Subscription ID? [yes/no] " response
case $response in 
	yes|y ) 
    echo "Managed Identity is in the same Subscription"
    break
    ;;
	no|n )
	read -r -p "Enter Subscription ID of Managed Identity: " managed_identity_subscription_id
    echo "export TF_VAR_managed_identity_subscription_id=${managed_identity_subscription_id}" >> .zsecrc
    break
    ;;
	* ) echo "invalid response. Please enter yes or no";;
    esac
done  
    read -r -p "Enter Managed Identity Name: " cc_vm_managed_identity_name 
    echo "export TF_VAR_cc_vm_managed_identity_name=${cc_vm_managed_identity_name}" >> .zsecrc
    read -r -p "Enter Managed Identity Resource Group: " cc_vm_managed_identity_rg
    echo "export TF_VAR_cc_vm_managed_identity_rg=${cc_vm_managed_identity_rg}" >> .zsecrc
    
cc_count_default=2
if [[ "$dtype" == *"lb"* ]]; then
    read -r -p "Enter how many Cloud Connectors to deploy? [Default=$cc_count_default]: " cc_count_input
cc_count=${cc_count_input:-$cc_count_default}
if ((cc_count >= 1 && cc_count <= 20)); then
    echo "${dtype} will deploy ${cc_count} Cloud Connector in ${azure_location}"
    echo "export TF_VAR_cc_count=${cc_count}" >> .zsecrc
else
    echo "invalid cc_count value. Must be a number between 1 and 20"
    echo "Delete .zsecrc file and re-run zsec up..."
    exit 1
fi
elif [[ "$dtype" == "base_1cc" ]]; then
    echo "${dtype} will deploy one Cloud Connector in ${azure_location}"   
fi

az_supported_regions=["australiaeast","Australia East","brazilsouth","Brazil South","canadacentral","Canada Central","centralindia","Central India","centralus","Central US","eastasia","East Asia","eastus","East US","francecentral","France Central","germanywestcentral","Germany West Central","japaneast","Japan East","koreacentral","Korea Central","northeurope","North Europe","norwayeast","Norway East","southafricanorth","South Africa North","southcentralus","South Central US","southeastasia","Southeast Asia","swedencentral","Sweden Central","uksouth","UK South","westeurope","West Europe","westus2","West US 2","westus3","West US 3","chinanorth3","China North 3","ChinaNorth3"]
if [[ ${az_supported_regions[*]} =~ $azure_location ]]; then
echo "Azure region ${azure_location} supports Zones..."
zones_enabled_default=no
    while true; do
    read -r -p "Deploy Cloud Connectors in dedicated Availability Zones/subnets? (Enter yes or no) [Default=$zones_enabled_default]: " zones_enabled_input
    zones_enabled=${zones_enabled_input:-$zones_enabled_default}
case $zones_enabled in 
	yes|y )
    echo "export TF_VAR_zones_enabled=true" >> .zsecrc
    break
    ;;
	no|n )
    echo "export TF_VAR_zones_enabled=false" >> .zsecrc
    echo "No zones defined. Proceeding with availability sets fault tolerance..."
    break
    ;;
	* ) echo "invalid response. Please enter yes or no";;
    esac
done  


if [[ "$zones_enabled" == "yes" || "$zones_enabled" == "y" ]]; then
    echo "Choose zones [1-3] to deploy in... "
    echo "If deploying only one Cloud Connector, enter yes for only one Zone (1, 2, or 3)"
    while true; do
    read -r -p "Zone 1 (yes/no): " zone1_response
case $zone1_response in 
	yes|y ) 
    echo "Availability Zone 1 selected"
    zone1_use=true
    break
    ;;
	no|n )
    zone1_use=false
    break
    ;;
	* ) echo "invalid response. Please enter yes or no";;
    esac
done 
    while true; do
    read -r -p "Zone 2 (yes/no): " zone2_response
case $zone2_response in 
	yes|y ) 
    echo "Availability Zone 2 selected"
    zone2_use=true
    break
    ;;
	no|n )
    zone2_use=false
    break
    ;;
	* ) echo "invalid response. Please enter yes or no";;
    esac
done
    while true; do
    read -r -p "Zone 3 (yes/no): " zone3_response
case $zone3_response in 
	yes|y ) 
    echo "Availability Zone 3 selected"
    zone3_use=true
    break
    ;;
	no|n )
    zone3_use=false
    break
    ;;
	* ) echo "invalid response. Please enter yes or no";;
    esac
done 
if [[ "$zone1_use" == "true" && "$zone2_use" == "false" && "$zone3_use" == "false" ]]; then
    echo "Zones selected: 1"
    echo "export TF_VAR_zones='[\"1\"]'" >> .zsecrc
elif [[ "$zone1_use" == "false" && "$zone2_use" == "true" && "$zone3_use" == "false" ]]; then
    echo "Zones selected: 2"
    echo "export TF_VAR_zones='[\"2\"]'" >> .zsecrc
elif [[ "$zone1_use" == "false" && "$zone2_use" == "false" && "$zone3_use" == "true" ]]; then
    echo "Zones selected: 3"
    echo "export TF_VAR_zones='[\"3\"]'" >> .zsecrc
elif [[ "$zone1_use" == "true" && "$zone2_use" == "true" && "$zone3_use" == "false" ]]; then
    echo "Zones selected: 1 and 2"
    echo "export TF_VAR_zones='[\"1\", \"2\"]'" >> .zsecrc
elif [[ "$zone1_use" == "true" && "$zone2_use" == "true" && "$zone3_use" == "true" ]]; then
    echo "Zones selected: 1, 2, and 3"
    echo "export TF_VAR_zones='[\"1\", \"2\", \"3\"]'" >> .zsecrc
elif [[ "$zone1_use" == "true" && "$zone2_use" == "false" && "$zone3_use" == "true" ]]; then
    echo "Zones selected: 1 and 3"
    echo "export TF_VAR_zones='[\"1\", \"3\"]'" >> .zsecrc  
elif [[ "$zone1_use" == "false" && "$zone2_use" == "true" && "$zone3_use" == "true" ]]; then
    echo "Zones selected: 2 and 3"
    echo "export TF_VAR_zones='[\"2\", \"3\"]'" >> .zsecrc   
else
    echo "Invalid Zones selection. exiting..."
    echo "Delete .zsecrc file and re-run zsec up..."
    exit 1
  fi 
fi
else
echo "Azure region ${azure_location} does not support Zones. Proceeding..."
fi

if [[ "$dtype" == "cc"* ]]; then
   while true; do
    read -r -p "Enable Azure Private DNS for ZPA? (yes/no): " zpa_response
case $zpa_response in 
	yes|y ) 
    echo "Enabling Azure Private DNS module..."
    zpa_enabled=true
    echo "export TF_VAR_zpa_enabled=$zpa_enabled" >> .zsecrc
    break
    ;;
	no|n )
    echo "No ZPA enablement..."
    zpa_enabled=false
    echo "export TF_VAR_zpa_enabled=$zpa_enabled" >> .zsecrc
    break
    ;;
	* ) echo "invalid response. Please enter yes or no";;
    esac
done 
fi

if [[ "$zpa_enabled" == "true" || "$dtype" == *"zpa" ]]; then
array=()
domain_names_map="'{ "
counter=0
while true; do
read -r -p "How many Domain/FQDN application segments to add to Private DNS Resolver Rules? " domain_number
if [[ $domain_number == 0 ]]; then
    echo "Invalid input. Please enter a whole number for the number of domains you will be adding..."
elif [[ $domain_number =~ ^[0-9]+$ ]]; then
   echo "$domain_number domains to enter..."
   break
else
   echo "Invalid input. Please enter a whole number for the number of domains you will be adding..."
fi
done
for i in $(seq $domain_number); do
read -r -p "Enter a single ZPA Domain/FQDN ending with a trailing dot ( e.g. azure.company.com. ): " domain_name
    if [[ $domain_name = *" "* ]]; then
        echo "Spaces not allowed. Please enter only one domain at a time. Delete .zsecrc file and re-run zsec up..."
        exit 1
    elif [[ $domain_name == '' ]]; then
        echo "Empty entries are not allowed. Delete .zsecrc file and re-run zsec up..."
        exit 1
    elif [[ $domain_name == "." ]]; then
        echo "You entered '.' dot. While Azure does support this to forward all domain requests, this could have unintended consequences/compatibility issues with Azure services"
    elif [[ $domain_name == "."* ]]; then
        echo "Invalid format. Domains cannot start with a dot (.). Delete .zsecrc file and re-run zsec up..."
        exit 1
    elif [[ $domain_name == "*"* ]]; then
        echo "Invalid format. Domains cannot start with a star/wildcard (*). Delete .zsecrc file and re-run zsec up..."
        exit 1
    elif [[ $domain_name != *"." ]]; then
        echo "Invalid format. Domains must end with a dot (.). Delete .zsecrc file and re-run zsec up..."
        exit 1
    fi
array+=("$domain_name")
    counter=$(( $counter + 1 ))
    domain_names_map+="appseg$counter: \"$domain_name\", "
done
domain_names_map+="}'"
echo "export TF_VAR_domain_names=$domain_names_map" >> .zsecrc
fi

fi


 #add local bin directory to PATH
if ! grep -Fxq "export PATH=\${PATH}:\${PWD}/bin" .zsecrc; then
    echo 'export PATH=${PATH}:${PWD}/bin' >> .zsecrc
fi

# add deployment type to .zsecrc for future runs
if [[ "$oper" == "up" ]]; then
    echo "Updating .zsecrc with dtype of $dtype"
    sed -i'' -e '/dtype/d' .zsecrc
    echo "export dtype=${dtype}" >> .zsecrc
fi

# initialize environment variables
. ./.zsecrc

# check for valid environment variables in .zsecrc
if [ -z "$ARM_CLIENT_ID" ] || [ -z "$ARM_CLIENT_SECRET" ] || [ -z "$ARM_SUBSCRIPTION_ID" ] || [ -z "$ARM_TENANT_ID" ] || [ -z "$TF_VAR_arm_location" ]; then
    echo "Azure Access info is missing. Remove .zsecrc file and rerun $0 $1"
    exit 1
fi

if [[ $dtype != "base" ]]; then
    echo "Checking Cloud Connector provisioning info"
  if [ -z "$TF_VAR_cc_vm_prov_url" ] || [ -z "$TF_VAR_azure_vault_url" ] || [ -z "$TF_VAR_http_probe_port" ] || [ -z "$TF_VAR_cc_instance_size" ] || [ -z "$TF_VAR_ccvm_instance_type" ] || [ -z "$TF_VAR_cc_vm_managed_identity_name" ] || [ -z "$TF_VAR_cc_vm_managed_identity_rg" ]; then
    echo "Cloud Connector provisioning info is missing. Remove .zsecrc file and rerun $0 $1"
    exit 1
  fi
fi


echo "Download terraform binary for $ostype if not present..."
if [[ ! -e ./$dir/terraform ]]; then
    curl -o ./$dir/terraform_${tversion}_${arch}.zip https://releases.hashicorp.com/terraform/$tversion/terraform_${tversion}_${os_str}_${arch}.zip
    unzip ./$dir/terraform_${tversion}_${arch}.zip -d ./$dir
    rm -f ./$dir/terraform_${tversion}_${arch}.zip
fi

if [[ "$oper" == "do" ]]; then
    exit 1
fi

if [[ "$oper" == "up" ]]; then
    echo "Bringing up Cloud Connector cluster..."
    TF_DATA_DIR=../.terraform ./$dir/terraform -chdir="$dtype" init
    if [[ "$AUTO_APPROVE" ]]; then
        TF_DATA_DIR=../.terraform ./$dir/terraform -chdir="$dtype" apply -auto-approve
    else
        TF_DATA_DIR=../.terraform ./$dir/terraform -chdir="$dtype" apply
    fi

elif [[ "$oper" == "destroy" ]]; then
    echo "Destroying Cloud Connector cluster..."
    TF_DATA_DIR=../.terraform ./$dir/terraform -chdir="$dtype" init
    if [[ "$AUTO_APPROVE" ]]; then
        TF_DATA_DIR=../.terraform ./$dir/terraform -chdir="$dtype" destroy -auto-approve
    else
      TF_DATA_DIR=../.terraform ./$dir/terraform -chdir="$dtype" destroy
    fi
    echo "Removing Terraform files and directories..."
    rm -rf bin 
    rm -rf **/.terraform/* && rm -rf **/.terraform*
    find . -type f -name '.terraform.lock.hcl' -delete
    rm -rf .terraform* && rm -f terraform.tfstate*
    rm -f *.pem && rm -f *.pem.pub
    rm -f name_prefix random_string
    rm -rf user.key user.crt
    rm -rf systems.json setup-*.tar
    rm -rf **/errorlog.txt
now=$(date +'%Y-%m-%d-%H_%M_%S')
    echo "archiving .zsecrc file to .zsecrc-${now}"
    cp .zsecrc .zsecrc-${now}
    rm -rf .zsecrc && rm -rf .zsecrc.bak
fi
